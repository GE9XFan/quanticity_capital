# 2.4 Positions Implementation

## Overview

Positions are streamed from Interactive Brokers via two mechanisms:

1. `reqAccountUpdates` ‚Üí `updatePortfolio` callback (real-time while subscribed).
2. `reqPositions` ‚Üí `position` callback (on-demand snapshot across all accounts).

Both feeds funnel into `AccountService`, which de-duplicates and persists the data.

---

## Request Helpers

```python
client.req_account_updates(True, account_id)
client.req_positions()
```

- Use `cancel_account_updates()` / `cancel_positions()` to end subscriptions.
- `reqPositions` returns a batch terminating with `positionEnd`.

---

## Callback Handling

- `updatePortfolio(...)` is wrapped by `handle_portfolio_position()`.
- `position(...)` is wrapped by `handle_position_snapshot()`.
- Contracts are normalised via `contract_from_ib()` and upserted into PostgreSQL.

Redis payload (`ib:account:{account}:positions` hash):

```json
{
  "8314": {
    "symbol": "IBM",
    "position": "100",
    "avg_cost": "150.00",
    "market_price": "151.20",
    "timestamp": "2024-01-01T12:00:00Z"
  }
}
```

PostgreSQL persistence (`positions` table) occurs when either:

- The signature `(position, avg_cost, market_price, market_value, unrealized_pnl, realized_pnl)` changes, or
- The last snapshot is older than `position_persist_interval` seconds (default 60s).

---

## Testing

- Unit coverage: `tests/unit/test_account_service.py::test_position_snapshot_only_persists_when_changed`.
- Live integration (requires IB Gateway + env): `tests/integration/test_positions.py` (guarded by `RUN_IB_POSITION_TESTS`).

---

## Troubleshooting

- Ensure `reqPositions` is cancelled; otherwise IB continues streaming incremental updates.
- If Redis lacks position keys, confirm TTL hasn't expired (default 300s) and that the subscription is active.
- For persistence issues, watch Postgres logs for constraint violations (contract FK) and verify migrations are applied.

---

## üêõ Bugs Fixed (2025-10-03)

### Bug #1: Redis Position Storage Used Raw Floats (`updatePortfolio`)

**File:** `src/brokers/ib/account.py:397-414`

**Problem:**
Redis storage for positions from `updatePortfolio` callback was storing raw IB float values instead of using the Pydantic model's Decimal-converted fields.

```python
# ‚ùå WRONG - Raw floats from IB
position_data = {
    "avg_cost": averageCost,  # float
    "market_price": marketPrice,  # float
}
```

**Impact:** Redis cache had lower precision than PostgreSQL storage.

**Fix:**
```python
# ‚úÖ CORRECT - Use Pydantic model fields (already Decimal)
position_data = {
    "avg_cost": str(position_model.avg_cost),
    "market_price": str(position_model.market_price),
}
```

**Verification:** Run `test_COMPREHENSIVE_data_verification.py` to verify Redis ‚Üî PostgreSQL match.

---

### Bug #2: Redis Position Storage Used Raw Floats (`position` callback)

**File:** `src/brokers/ib/account.py:471-480`

**Problem:**
Same issue as Bug #1 but in the `position` callback (from `reqPositions`).

```python
# ‚ùå WRONG
"avg_cost": str(avgCost)  # Raw float ‚Üí string
```

**Fix:**
```python
# ‚úÖ CORRECT
"avg_cost": str(position_model.avg_cost)  # Decimal ‚Üí string
```

**Impact:** Same as Bug #1 - precision loss in Redis cache.

---

## ‚úÖ Verification Status

**Date:** 2025-10-03
**Test:** `tests/integration/test_COMPREHENSIVE_data_verification.py`
**Result:** ‚úÖ All bugs fixed

**Verified:**
- Position fields use Decimal precision throughout
- Redis cache matches PostgreSQL storage exactly
- No precision loss from float ‚Üí Decimal ‚Üí string conversions
- All contract fields captured correctly

