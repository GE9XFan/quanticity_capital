# 2.1 Interactive Brokers Connection

## Overview

This document describes the Interactive Brokers (IB) API integration for connecting to TWS (Trader Workstation) or IB Gateway. The implementation follows the official IB API connectivity guidelines and uses the native Python API (version 10.37.2) provided by Interactive Brokers.

**Status:** ✓ Fully tested and operational
**API Version:** 10.37.2
**Last Updated:** 2025-10-03
**Test Coverage:** Connection establishment, error handling, multi-client support

---

## Table of Contents

1. [Architecture](#architecture)
2. [Connection Flow](#connection-flow)
3. [Implementation Details](#implementation-details)
4. [Configuration](#configuration)
5. [Usage Examples](#usage-examples)
6. [Testing](#testing)
7. [Error Handling](#error-handling)
8. [Multi-Client Support](#multi-client-support)
9. [Troubleshooting](#troubleshooting)
10. [API Version Notes](#api-version-notes)
11. [References](#references)

---

## Architecture

### Directory Structure

```
src/brokers/ib/
├── __init__.py
├── config.py       # Configuration management
└── client.py       # Main IB client implementation
```

### Core Components

#### 1. IBClient (`src/brokers/ib/client.py`)

The `IBClient` class combines `EWrapper` (callback handler) and `EClient` (request sender) to manage the API connection.

**Class Definition:**
```python
class IBClient(EWrapper, EClient):
    """
    IB API Client combining EWrapper (callbacks) and EClient (requests)

    Connection Flow (Python API):
    1. connect() - establish socket connection (EReader thread auto-created)
    2. connectAck() - callback confirms connection
    3. run() - process message queue in infinite loop
    4. nextValidId() - signals ready to send messages

    Note: In Python, EReader is automatically handled by EClient.connect()
    """
```

**Key Features:**
- Automatic EReader thread management (handled by Python API)
- Thread-safe connection state tracking
- Comprehensive error handling with API 10.37+ support
- Connection state synchronization via threading.Event
- Clean disconnection handling

**State Management:**
- `next_valid_order_id` - Next valid order ID from TWS (set by `nextValidId()`)
- `connected_event` - Threading event that signals when connection is ready
- `is_running` - Flag indicating message processing loop is active

#### 2. IBConfig (`src/brokers/ib/config.py`)

Configuration dataclass for managing connection parameters.

**Default Configuration:**
```python
@dataclass
class IBConfig:
    host: str = "127.0.0.1"
    port: int = 7497  # Paper trading
    client_id: int = 0
```

**Environment Variable Support:**
- `IB_HOST` - IP address of TWS/IB Gateway (default: 127.0.0.1)
- `IB_PORT` - Socket port (7497 for paper, 7496 for live)
- `IB_CLIENT_ID` - Unique client identifier 0-31 (default: 0)

---

## Connection Flow

### Python API Connection Sequence

The Python IB API handles connection differently than other language implementations. Understanding this is critical:

```
1. client.connect(host, port, client_id)
   ↓
2. Socket connection established
   ↓
3. EReader thread automatically created by EClient.connect()
   ↓
4. connectAck() callback fired
   ↓
5. Initial handshake (version negotiation)
   ↓
6. Message queue processing begins
   ↓
7. nextValidId() callback fired
   ↓
8. ✓ Connection Ready - Messages can be sent
   ↓
9. client.run() processes message queue in infinite loop
```

### Critical Differences from Other Languages

**Python API Specifics:**

1. **No Manual EReader Creation Required**
   - In Java/C++/C#, you must manually create and start the EReader thread
   - In Python, `EClient.connect()` automatically creates the EReader thread
   - The EReader thread automatically reads from socket and queues messages

2. **run() Method**
   - Simply calls `super().run()` to use inherited EClient implementation
   - EClient.run() processes the message queue in an infinite loop
   - Each message is automatically decoded and routed to EWrapper callbacks

3. **Message Queue Handling**
   - Message queue is automatically managed by the Queue class
   - No need for EReaderSignal - handled automatically by Queue
   - Thread-safe by design

### Callback Sequence

**On Successful Connection:**
```
connectAck() → nextValidId() → [connection ready]
```

**On Connection Failure:**
```
error(502, "Cannot connect to TWS") → connectionClosed()
```

**On Disconnection:**
```
connectionClosed() → [cleanup]
```

---

## Implementation Details

### Connection Methods

#### `__init__()`

Initializes the client with default state.

```python
def __init__(self):
    EClient.__init__(self, wrapper=self)
    self.next_valid_order_id = None
    self.connected_event = threading.Event()
    self.is_running = False
```

**State Variables:**
- `next_valid_order_id`: None until `nextValidId()` is called
- `connected_event`: Threading.Event() for synchronization
- `is_running`: False until `run()` is called

---

#### `connect(host, port, client_id)`

Establishes socket connection to TWS/IB Gateway.

```python
client = IBClient()
client.connect("127.0.0.1", 7497, 0)
```

**Parameters:**
- `host` (str): IP address, typically "127.0.0.1" for localhost
- `port` (int): Socket port (7497 for paper, 7496 for live)
- `client_id` (int): Unique client identifier (0-31)

**Behavior:**
- Opens TCP socket to specified host:port
- Automatically creates EReader thread (Python API feature)
- Begins version negotiation handshake
- Returns immediately (non-blocking)

**Error Handling:**
- Error 502: Connection refused (TWS not running or wrong port)
- Error -1: Socket exception

---

#### `run()`

Main message processing loop. Must be called in a separate thread.

```python
thread = threading.Thread(target=client.run, daemon=True)
thread.start()
```

**Implementation:**
```python
def run(self):
    self.is_running = True
    super().run()  # Use EClient's built-in run() method
```

**Behavior:**
- Sets `is_running` flag to True
- Calls inherited `EClient.run()` which processes message queue
- Runs in infinite loop until connection is closed
- Automatically decodes messages and triggers EWrapper callbacks

**Threading:**
- Should be run in a separate daemon thread
- Blocks until connection is closed or error occurs
- Thread-safe message processing

---

#### `disconnect()`

Cleanly closes the connection.

```python
client.disconnect()
```

**Behavior:**
- Sets `is_running` flag to False
- Closes socket connection via `EClient.disconnect()`
- Triggers `connectionClosed()` callback
- Stops message processing loop

**Cleanup:**
- Clears `connected_event`
- Resets connection state
- Thread-safe

---

#### `wait_for_connection(timeout)`

Helper method to wait for connection to be fully established.

```python
if client.wait_for_connection(timeout=10):
    print("Connected successfully")
else:
    print("Connection timeout")
```

**Parameters:**
- `timeout` (int): Maximum seconds to wait (default: 10)

**Returns:**
- `bool`: True if connected, False if timeout

**Usage Pattern:**
```python
client.connect(host, port, client_id)
thread = threading.Thread(target=client.run, daemon=True)
thread.start()

if client.wait_for_connection(timeout=10):
    # Connection ready - nextValidId() has been called
    print(f"Ready to trade. Next order ID: {client.next_valid_order_id}")
else:
    # Timeout - connection failed
    print("Connection failed")
    client.disconnect()
```

---

### EWrapper Callbacks

#### `connectAck()`

Called when socket connection is first established.

**Signature:**
```python
def connectAck(self):
    print("✓ API Connection Established")
```

**Timing:**
- Called immediately after socket connection opens
- Called before version negotiation
- Does NOT mean connection is ready for trading
- Wait for `nextValidId()` before sending requests

---

#### `nextValidId(orderId)`

**Most Important Callback** - Signals connection is complete and ready for messages.

**Signature:**
```python
def nextValidId(self, orderId: int):
    self.next_valid_order_id = orderId
    print(f"✓ Connection Ready - Next Valid Order ID: {orderId}")
    self.connected_event.set()
```

**Parameters:**
- `orderId` (int): Next valid order ID for this session

**Behavior:**
- Called after version negotiation completes
- Signals that TWS is ready to receive requests
- Provides the starting order ID for this session
- Sets `connected_event` to unblock `wait_for_connection()`

**Critical:**
- Do NOT send requests before this callback
- Requests sent before `nextValidId()` may be dropped by TWS

---

#### `connectionClosed()`

Called when connection is lost or closed.

**Signature:**
```python
def connectionClosed(self):
    print("✗ API Connection Closed")
    self.connected_event.clear()
    self.is_running = False
```

**Triggers:**
- Manual disconnect via `client.disconnect()`
- TWS/IB Gateway closes unexpectedly
- Network interruption
- Socket error

**Behavior:**
- Clears `connected_event`
- Sets `is_running` to False
- Stops message processing loop

**Use Case:**
- Implement reconnection logic here
- Log disconnection events
- Alert monitoring systems

---

#### `error(reqId, errorCode, errorString, errorTime, advancedOrderRejectJson)`

Handles errors and informational messages from TWS.

**Signature (API 10.37+):**
```python
def error(self, reqId: int, errorCode: int = None,
          errorString: str = "", errorTime: str = "",
          advancedOrderRejectJson: str = ""):
```

**Parameters:**
- `reqId` (int): Request ID that triggered the error (or -1 for system messages)
- `errorCode` (int): Error code (None for old signature compatibility)
- `errorString` (str): Human-readable error message
- `errorTime` (str): Timestamp (new in API 10.37+)
- `advancedOrderRejectJson` (str): Additional rejection details in JSON

**Important Error Codes:**

| Code | Meaning | Action Required |
|------|---------|----------------|
| 502 | Cannot connect to TWS | Start TWS/IB Gateway, check port |
| 507 | Bad message / socket broken | Check network, restart connection |
| -1 | Socket exception | Network issue or TWS crash |
| 2104 | Market data farm connection OK | Informational |
| 2106 | HMDS data farm connection OK | Informational |
| 2158 | Sec-def data farm connection OK | Informational |

**Behavior:**
```python
# Error 502 example
if errorCode == 502:
    print(f"✗ ERROR {errorCode}: {errorString}")
    print("  → Check that TWS/IB Gateway is running with API enabled")

# Informational messages (2104, 2106, etc.)
else:
    print(f"IB Message [{errorCode}]: {errorString}")
```

**Note:** Many "errors" are actually informational messages about connection status.

---

## Configuration

### Environment Variables

Add to `.env` file:

```bash
# Interactive Brokers API Configuration
IB_HOST=127.0.0.1
IB_PORT=7497        # 7497 for paper, 7496 for live
IB_CLIENT_ID=0
```

### Loading Configuration

**From Environment:**
```python
from src.brokers.ib.config import IBConfig

# Load from .env
config = IBConfig.from_env()
```

**Manual Configuration:**
```python
from src.brokers.ib.config import IBConfig

# Create manually
config = IBConfig(
    host="127.0.0.1",
    port=7497,
    client_id=0
)
```

### Trading Modes

#### Paper Trading (Default)
- **Port:** 7497
- **Use for:** Development, testing, strategy validation
- **Risk:** None - simulated trading
- **Configuration:** `IB_PORT=7497`

#### Live Trading
- **Port:** 7496
- **Use for:** Production trading
- **Risk:** Real money
- **Configuration:** `IB_PORT=7496`

**⚠️ WARNING:** Always thoroughly test with paper trading before switching to live trading.

---

## Usage Examples

### Basic Connection

```python
import threading
from src.brokers.ib.client import IBClient
from src.brokers.ib.config import IBConfig

# Load configuration from .env
config = IBConfig.from_env()

# Create client
client = IBClient()

# Connect
client.connect(config.host, config.port, config.client_id)

# Start message processing in separate thread
thread = threading.Thread(target=client.run, daemon=True)
thread.start()

# Wait for connection to be ready
if client.wait_for_connection(timeout=10):
    print("✓ Connected and ready")
    print(f"Next Valid Order ID: {client.next_valid_order_id}")

    # Your trading logic here
    # ...

    # Disconnect when done
    client.disconnect()
else:
    print("✗ Connection timeout")
    client.disconnect()
```

### Connection with Error Handling

```python
import threading
import time
from src.brokers.ib.client import IBClient
from src.brokers.ib.config import IBConfig

def connect_with_retry(max_retries=3):
    config = IBConfig.from_env()

    for attempt in range(max_retries):
        try:
            print(f"Connection attempt {attempt + 1}/{max_retries}")

            client = IBClient()
            client.connect(config.host, config.port, config.client_id)

            thread = threading.Thread(target=client.run, daemon=True)
            thread.start()

            if client.wait_for_connection(timeout=10):
                print("✓ Connection successful")
                return client
            else:
                print("✗ Connection timeout")
                client.disconnect()

        except Exception as e:
            print(f"✗ Connection error: {e}")

        if attempt < max_retries - 1:
            print(f"Retrying in 5 seconds...")
            time.sleep(5)

    return None

# Use the connection
client = connect_with_retry()
if client:
    # Trading logic
    pass
    # Cleanup
    client.disconnect()
```

### Multiple Simultaneous Connections

```python
import threading
from src.brokers.ib.client import IBClient
from src.brokers.ib.config import IBConfig

config = IBConfig.from_env()

# Create two clients with different IDs
client1 = IBClient()
client2 = IBClient()

# Connect client 1
client1.connect(config.host, config.port, client_id=0)
thread1 = threading.Thread(target=client1.run, daemon=True)
thread1.start()

# Connect client 2
client2.connect(config.host, config.port, client_id=1)
thread2 = threading.Thread(target=client2.run, daemon=True)
thread2.start()

# Wait for both to connect
if client1.wait_for_connection(timeout=10) and client2.wait_for_connection(timeout=10):
    print(f"✓ Both connected")
    print(f"Client 1 order ID: {client1.next_valid_order_id}")
    print(f"Client 2 order ID: {client2.next_valid_order_id}")

    # Use both clients
    # ...

    # Cleanup
    client1.disconnect()
    client2.disconnect()
```

---

## Testing

### Running Integration Tests

**Prerequisites:**
- TWS or IB Gateway must be running
- API enabled in TWS: Edit → Global Configuration → API → Settings
- "Enable ActiveX and Socket Clients" checked
- Port 7497 configured for paper trading

**Run All Tests:**
```bash
# With pytest
pytest tests/integration/test_ib_connection.py -v -s

# Direct execution
python tests/integration/test_ib_connection.py
```

### Test Coverage

The test suite includes three comprehensive integration tests:

#### Test 1: Connection Establishment
**Purpose:** Verify basic connection functionality

**Steps:**
1. Create IBClient instance
2. Connect to TWS/IB Gateway
3. Start message processing thread
4. Wait for `nextValidId()` callback
5. Verify `isConnected()` returns True
6. Verify `next_valid_order_id` is set
7. Check connection stability (1 second)
8. Disconnect cleanly

**Expected Result:** ✓ All connection tests passed

---

#### Test 2: Error Handling
**Purpose:** Verify proper handling of connection failures

**Steps:**
1. Attempt connection to invalid port (9999)
2. Verify connection fails
3. Verify `isConnected()` returns False
4. Verify error callback is triggered

**Expected Result:** ✓ Error handling tests passed

---

#### Test 3: Multiple Connections
**Purpose:** Verify TWS multi-client support

**Steps:**
1. Connect client 1 with ID=0
2. Connect client 2 with ID=1
3. Verify both receive `nextValidId()`
4. Verify both are simultaneously connected
5. Verify each has unique order IDs
6. Disconnect both clients

**Expected Result:** ✓ Multiple connection tests passed

---

### Test Results (Last Run: 2025-10-03)

```
============================================================
✓✓✓ ALL TESTS PASSED ✓✓✓
============================================================

[TEST 1/3] Connection Establishment               ✓
[TEST 2/3] Error Handling                         ✓
[TEST 3/3] Multiple Connections                   ✓

Test Environment:
- IB API Version: 10.37.2
- Python Version: 3.11
- TWS Version: Build 952.x+
- Trading Mode: Paper (Port 7497)
```

---

## Error Handling

### Connection Errors

#### Error 502: Cannot Connect to TWS

**Cause:**
- TWS/IB Gateway is not running
- API is not enabled in TWS settings
- Wrong port number
- Firewall blocking connection

**Resolution:**
1. Start TWS or IB Gateway
2. Enable API: Edit → Global Configuration → API → Settings
3. Check "Enable ActiveX and Socket Clients"
4. Verify port number (7497 for paper, 7496 for live)
5. Check firewall settings

---

#### Error 507: Bad Message / Socket Broken

**Cause:**
- Socket connection interrupted
- TWS closed unexpectedly
- Network issue
- Version mismatch

**Resolution:**
1. Check network connectivity
2. Restart TWS/IB Gateway
3. Verify IB API version compatibility
4. Implement reconnection logic

---

#### Error -1: Socket Exception

**Cause:**
- Network interruption
- TWS crash
- Connection forcibly closed

**Resolution:**
1. Check network stability
2. Review TWS logs (Help → Log Viewer)
3. Implement automatic reconnection
4. Monitor system resources

---

### Client ID Errors

**Cause:** Attempting to connect with a client_id already in use

**Message:** "Socket connection broken"

**Resolution:**
- Use unique client_id for each connection (0-31)
- Properly disconnect previous connections
- Check for orphaned connections

---

### Informational Messages

These are NOT errors, but status messages:

| Code | Message | Meaning |
|------|---------|---------|
| 2104 | Market data farm connection is OK | Market data connection established |
| 2106 | HMDS data farm connection is OK | Historical data connection established |
| 2158 | Sec-def data farm connection is OK | Security definition connection established |

**Action:** None required - informational only

---

## Multi-Client Support

### Overview

TWS supports up to 32 simultaneous API client connections per TWS instance.

### Key Points

**Client IDs:**
- Must be unique per TWS instance (0-31)
- Each client maintains separate session
- Each receives unique `next_valid_order_id`

**Use Cases:**
- Multiple strategies running simultaneously
- Separate data feed and trading connections
- Load balancing across connections
- Redundancy/failover setups

**Example:**
```python
# Strategy 1
client_strategy1 = IBClient()
client_strategy1.connect("127.0.0.1", 7497, client_id=0)

# Strategy 2
client_strategy2 = IBClient()
client_strategy2.connect("127.0.0.1", 7497, client_id=1)

# Market data feed
client_data = IBClient()
client_data.connect("127.0.0.1", 7497, client_id=2)
```

### Multiple TWS Instances

To run multiple TWS instances on same computer:
- Each TWS must use different socket port
- Configure in TWS: Edit → Global Configuration → API → Settings
- Example: TWS 1 on port 7497, TWS 2 on port 7498

---

## Troubleshooting

### Connection Checklist

**1. Verify TWS is Running:**
```bash
# Check if port is listening
netstat -an | grep 7497
# Should show: tcp4  0  0  127.0.0.1.7497  *.*  LISTEN
```

**2. Check API Settings:**
- Edit → Global Configuration → API → Settings
- ✓ "Enable ActiveX and Socket Clients" checked
- ✓ Socket port = 7497 (or your configured port)
- ✓ "Allow connections from the localhost only" checked (if running locally)

**3. Test Socket Connection:**
```bash
telnet 127.0.0.1 7497
# Should connect without "Connection refused"
```

**4. Verify Python Environment:**
```bash
# Check ibapi is installed
python -c "import ibapi; print(ibapi.__version__)"
# Should print: 10.37.2 (or your version)

# Check protobuf is installed
python -c "import google.protobuf; print('protobuf OK')"
# Should print: protobuf OK
```

**5. Review Logs:**
- **TWS Logs:** Help → Log Viewer in TWS
- **Client Logs:** Check console output for error messages

---

### Common Issues

#### Issue: `nextValidId()` Never Called

**Symptoms:**
- `wait_for_connection()` times out
- Connection seems stuck

**Causes:**
- TWS license expired
- TWS needs user interaction (login dialog, notifications)
- Version incompatibility

**Resolution:**
- Check TWS for dialog boxes or alerts
- Verify TWS is fully logged in
- Update to latest TWS version

---

#### Issue: Connection Drops Immediately

**Symptoms:**
- `connectAck()` called
- `connectionClosed()` called immediately after
- No `nextValidId()`

**Causes:**
- client_id already in use
- TWS rejecting connection
- Network instability

**Resolution:**
- Use different client_id
- Check TWS connection settings
- Review TWS logs for rejection reason

---

#### Issue: Import Errors

**Symptoms:**
```
ModuleNotFoundError: No module named 'ibapi'
ModuleNotFoundError: No module named 'google'
```

**Resolution:**
```bash
# Install ibapi from official source
cd ~/Downloads/twsapi_macunix/IBJts/source/pythonclient
python setup.py install

# Install protobuf
pip install protobuf==5.29.3
```

---

## API Version Notes

### Version 10.37.2 Specific Changes

**Critical Updates in 10.37+:**

1. **error() Callback Signature Changed**
   - **Old:** `error(reqId, errorCode, errorString, advancedOrderRejectJson)`
   - **New:** `error(reqId, errorCode, errorString, errorTime, advancedOrderRejectJson)`
   - **Impact:** Added `errorTime` parameter
   - **Solution:** Updated signature to support both old and new versions

2. **Protobuf Dependency**
   - **Required:** `protobuf==5.29.3`
   - **Impact:** Cannot use newer or older protobuf versions
   - **Reason:** IB API 10.37.2 has hard dependency on this version

3. **EReader Handling**
   - **Python:** Automatically handled by `EClient.connect()`
   - **Other Languages:** Must manually create and start EReader thread
   - **Impact:** Simplified Python implementation

### Compatibility Matrix

| IB API Version | Python Version | protobuf Version | TWS Version |
|----------------|---------------|------------------|-------------|
| 10.37.2 | 3.11+ | 5.29.3 | 952.x+ |
| 10.19.x | 3.11+ | 4.25.1 | 952.x+ |
| 9.81.x | 3.11+ | 4.21.x | 948.x+ |

### Upgrading from Previous Versions

**From API 9.81.x to 10.37.2:**

1. Update `error()` callback signature to include `errorTime`
2. Update protobuf: `pip install protobuf==5.29.3`
3. Reinstall ibapi from official source
4. Test all error handling code

**Migration Checklist:**
- [ ] Update error() method signature
- [ ] Update protobuf version
- [ ] Reinstall ibapi
- [ ] Run integration tests
- [ ] Verify error messages display correctly

---

## Prerequisites

### Software Requirements

**1. TWS or IB Gateway**
- Download from: https://www.interactivebrokers.com/
- Minimum version: Build 952.x
- Configuration: API enabled

**2. IB API Python Library (ibapi)**
- Version: 10.37.2
- Download from: https://interactivebrokers.github.io/
- Installation: Manual (see below)

**3. Python**
- Version: 3.11.0+ (minimum)
- Virtual environment recommended

**4. Dependencies**
- protobuf==5.29.3 (critical - exact version required)

### Installation Steps

**1. Install TWS or IB Gateway:**
- Download installer from Interactive Brokers
- Run installer and follow prompts
- Start application and login

**2. Enable API in TWS:**
- Edit → Global Configuration → API → Settings
- Check "Enable ActiveX and Socket Clients"
- Set Socket port (7497 for paper, 7496 for live)
- Optional: Check "Allow connections from the localhost only"
- Click OK and restart TWS if prompted

**3. Install IB API:**
```bash
# Download TWS API from https://interactivebrokers.github.io/
# Extract the download
cd ~/Downloads/twsapi_macunix/IBJts/source/pythonclient

# Install into virtual environment (with venv activated)
python setup.py install

# Verify installation
python -c "import ibapi; print(ibapi.__version__)"
# Should print: 10.37.2
```

**4. Install Protobuf:**
```bash
pip install protobuf==5.29.3
```

**5. Verify Setup:**
```bash
# Run integration tests
python tests/integration/test_ib_connection.py
```

---

## Performance Considerations

### Threading

**Message Processing:**
- EReader thread: Automatically created, reads from socket
- Message queue: Thread-safe Queue implementation
- Main thread: Processes messages and triggers callbacks

**Best Practices:**
- Run `client.run()` in daemon thread
- Don't block in callback methods
- Use thread-safe data structures for shared state
- Implement proper cleanup in `connectionClosed()`

### Resource Usage

**Memory:**
- Base client: ~10MB
- Message queue: Grows with unprocessed messages
- Recommendation: Process messages quickly to avoid queue buildup

**CPU:**
- Minimal when idle
- Spikes during high message volume (market data)
- Recommendation: Monitor queue size, throttle requests if needed

**Network:**
- Keep-alive messages sent periodically
- Bandwidth varies with market data subscriptions
- Recommendation: Stable connection with low latency

---

## Security Considerations

### Connection Security

**Localhost Only:**
- Default: Connections only from 127.0.0.1
- TWS Setting: "Allow connections from the localhost only"
- **Recommendation:** Keep enabled unless remote access needed

**Remote Connections:**
- Requires: Adding IP to "Trusted IPs" in TWS
- **Warning:** Only allow trusted IPs
- **Best Practice:** Use VPN for remote connections

### Credentials

**TWS Login:**
- Never store TWS username/password in code
- Use TWS's "remember password" feature carefully
- Consider using IB Gateway for headless operation

**Client ID:**
- Not a security feature
- Used for session management only
- Safe to hardcode or store in .env

---

## Future Enhancements

Potential additions to the IB integration:

- [ ] Automatic reconnection logic with exponential backoff
- [ ] Connection heartbeat monitoring and alerts
- [ ] Enhanced logging with Python logging module
- [ ] Metrics collection (connection uptime, message latency)
- [ ] Connection pool management for multiple strategies
- [ ] Market data subscriptions and handling
- [ ] Order placement and management
- [ ] Position and account info retrieval
- [ ] Historical data requests
- [ ] Contract search and details
- [ ] Real-time market data streaming

---

## References

### Official Documentation

- **IB API Documentation:** https://interactivebrokers.github.io/tws-api/
- **Connectivity Guide:** https://interactivebrokers.github.io/tws-api/initial_setup.html
- **Python API Guide:** https://interactivebrokers.com/campus/ibkr-api-page/twsapi-doc/
- **IB Python API Blog:** https://www.interactivebrokers.com/campus/ibkr-quant-news/interactive-brokers-python-api-native-a-step-by-step-guide/

### Download Links

- **TWS Download:** https://www.interactivebrokers.com/en/trading/tws.php
- **IB Gateway Download:** https://www.interactivebrokers.com/en/trading/ibgateway-stable.php
- **IB API Download:** https://interactivebrokers.github.io/

### Support Resources

- **IB API Forum:** https://groups.io/g/twsapi
- **IB Client Portal:** https://www.interactivebrokers.com/portal
- **IB Support:** https://www.interactivebrokers.com/en/support/contact.php

---

## Appendix: Complete Working Example

```python
"""
Complete IB Connection Example
Demonstrates proper connection, error handling, and cleanup
"""

import threading
import time
from src.brokers.ib.client import IBClient
from src.brokers.ib.config import IBConfig


def main():
    # Load configuration
    config = IBConfig.from_env()
    print(f"Configuration loaded:")
    print(f"  Host: {config.host}")
    print(f"  Port: {config.port}")
    print(f"  Client ID: {config.client_id}")
    print()

    # Create client
    client = IBClient()

    try:
        # Connect
        print("Connecting to IB Gateway...")
        client.connect(config.host, config.port, config.client_id)

        # Start message processing thread
        thread = threading.Thread(target=client.run, daemon=True)
        thread.start()
        print("Message processing thread started")

        # Wait for connection
        print("Waiting for connection...")
        if not client.wait_for_connection(timeout=10):
            print("✗ Connection timeout - exiting")
            return

        print(f"✓ Connected successfully!")
        print(f"Next Valid Order ID: {client.next_valid_order_id}")
        print()

        # Your trading logic here
        print("Running trading logic for 5 seconds...")
        time.sleep(5)

        print("Trading logic complete")

    except KeyboardInterrupt:
        print("\nInterrupted by user")
    except Exception as e:
        print(f"✗ Error: {e}")
    finally:
        # Always disconnect
        print("Disconnecting...")
        client.disconnect()
        print("✓ Disconnected")


if __name__ == "__main__":
    main()
```

---

## Document History

| Date | Version | Changes | Author |
|------|---------|---------|--------|
| 2025-10-03 | 1.0 | Initial documentation | System |
| 2025-10-03 | 2.0 | Updated with API 10.37.2 corrections and test results | System |

---

**End of Document**
